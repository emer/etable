// Code generated by "goki generate ./..."; DO NOT EDIT.

package etable

import (
	"goki.dev/gti"
	"goki.dev/ordmap"
)

var _ = gti.AddType(&gti.Type{
	Name:      "github.com/goki/etable/v2/etable.Table",
	ShortName: "etable.Table",
	IDName:    "table",
	Doc:       "etable.Table is the emer DataTable structure, containing columns of etensor tensors.\nAll tensors MUST have RowMajor stride layout!",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Cols", &gti.Field{Name: "Cols", Type: "[]github.com/goki/etable/v2/etensor.Tensor", LocalType: "[]etensor.Tensor", Doc: "columns of data, as etensor.Tensor tensors", Directives: gti.Directives{}, Tag: "view:\"no-inline\""}},
		{"ColNames", &gti.Field{Name: "ColNames", Type: "[]string", LocalType: "[]string", Doc: "the names of the columns", Directives: gti.Directives{}, Tag: ""}},
		{"Rows", &gti.Field{Name: "Rows", Type: "int", LocalType: "int", Doc: "number of rows, which is enforced to be the size of the outer-most dimension of the column tensors", Directives: gti.Directives{}, Tag: "edit:\"-\""}},
		{"ColNameMap", &gti.Field{Name: "ColNameMap", Type: "map[string]int", LocalType: "map[string]int", Doc: "the map of column names to column numbers", Directives: gti.Directives{}, Tag: "view:\"-\""}},
		{"MetaData", &gti.Field{Name: "MetaData", Type: "map[string]string", LocalType: "map[string]string", Doc: "misc meta data for the table.  We use lower-case key names following the struct tag convention:  name = name of table; desc = description; read-only = gui is read-only; precision = n for precision to write out floats in csv.  For Column-specific data, we look for ColName: prefix, specifically ColName:desc = description of the column contents, which is shown as tooltip in the etview.TableView, and :width for width of a column", Directives: gti.Directives{}, Tag: ""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{
		{"AddRows", &gti.Method{Name: "AddRows", Doc: "AddRows adds n rows to each of the columns", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
			{"n", &gti.Field{Name: "n", Type: "int", LocalType: "int", Doc: "", Directives: gti.Directives{}, Tag: ""}},
		}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{})}},
		{"SetNumRows", &gti.Method{Name: "SetNumRows", Doc: "SetNumRows sets the number of rows in the table, across all columns\nif rows = 0 then effective number of rows in tensors is 1, as this dim cannot be 0", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
			{"rows", &gti.Field{Name: "rows", Type: "int", LocalType: "int", Doc: "", Directives: gti.Directives{}, Tag: ""}},
		}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{})}},
		{"SaveCSV", &gti.Method{Name: "SaveCSV", Doc: "SaveCSV writes a table to a comma-separated-values (CSV) file\n(where comma = any delimiter, specified in the delim arg).\nIf headers = true then generate C++ emergent-tyle column headers.\nThese headers have full configuration information for the tensor\ncolumns.  Otherwise, only the data is written.", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
			{"filename", &gti.Field{Name: "filename", Type: "goki.dev/gi.FileName", LocalType: "gi.FileName", Doc: "", Directives: gti.Directives{}, Tag: ""}},
			{"delim", &gti.Field{Name: "delim", Type: "github.com/goki/etable/v2/etable.Delims", LocalType: "Delims", Doc: "", Directives: gti.Directives{}, Tag: ""}},
			{"headers", &gti.Field{Name: "headers", Type: "bool", LocalType: "bool", Doc: "", Directives: gti.Directives{}, Tag: ""}},
		}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
			{"error", &gti.Field{Name: "error", Type: "error", LocalType: "error", Doc: "", Directives: gti.Directives{}, Tag: ""}},
		})}},
		{"OpenCSV", &gti.Method{Name: "OpenCSV", Doc: "OpenCSV reads a table from a comma-separated-values (CSV) file\n(where comma = any delimiter, specified in the delim arg),\nusing the Go standard encoding/csv reader conforming to the official CSV standard.\nIf the table does not currently have any columns, the first row of the file\nis assumed to be headers, and columns are constructed therefrom.\nThe C++ emergent column headers are parsed -- these have full configuration\ninformation for tensor dimensionality.\nIf the table DOES have existing columns, then those are used robustly\nfor whatever information fits from each row of the file.", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
			{"filename", &gti.Field{Name: "filename", Type: "goki.dev/gi.FileName", LocalType: "gi.FileName", Doc: "", Directives: gti.Directives{}, Tag: ""}},
			{"delim", &gti.Field{Name: "delim", Type: "github.com/goki/etable/v2/etable.Delims", LocalType: "Delims", Doc: "", Directives: gti.Directives{}, Tag: ""}},
		}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
			{"error", &gti.Field{Name: "error", Type: "error", LocalType: "error", Doc: "", Directives: gti.Directives{}, Tag: ""}},
		})}},
	}),
})

var _ = gti.AddType(&gti.Type{
	Name:      "github.com/goki/etable/v2/etable.IdxView",
	ShortName: "etable.IdxView",
	IDName:    "idx-view",
	Doc:       "IdxView is an indexed wrapper around an etable.Table that provides a\nspecific view onto the Table defined by the set of indexes.\nThis provides an efficient way of sorting and filtering a table by only\nupdating the indexes while doing nothing to the Table itself.\nTo produce a table that has data actually organized according to the\nindexed order, call the NewTable method.\nIdxView views on a table can also be organized together as Splits\nof the table rows, e.g., by grouping values along a given column.",
	Directives: gti.Directives{
		&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
	},
	Fields: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
		{"Table", &gti.Field{Name: "Table", Type: "*github.com/goki/etable/v2/etable.Table", LocalType: "*Table", Doc: "Table that we are an indexed view onto", Directives: gti.Directives{}, Tag: ""}},
		{"Idxs", &gti.Field{Name: "Idxs", Type: "[]int", LocalType: "[]int", Doc: "current indexes into Table", Directives: gti.Directives{}, Tag: ""}},
		{"lessFunc", &gti.Field{Name: "lessFunc", Type: "github.com/goki/etable/v2/etable.LessFunc", LocalType: "LessFunc", Doc: "current Less function used in sorting", Directives: gti.Directives{}, Tag: "copy:\"-\" view:\"-\" xml:\"-\" json:\"-\""}},
	}),
	Embeds: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}),
	Methods: ordmap.Make([]ordmap.KeyVal[string, *gti.Method]{
		{"Sequential", &gti.Method{Name: "Sequential", Doc: "Sequential sets indexes to sequential row-wise indexes into table", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{})}},
		{"SortColName", &gti.Method{Name: "SortColName", Doc: "SortColName sorts the indexes into our Table according to values in\ngiven column name, using either ascending or descending order.\nOnly valid for 1-dimensional columns.\nReturns error if column name not found.", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
			{"colNm", &gti.Field{Name: "colNm", Type: "string", LocalType: "string", Doc: "", Directives: gti.Directives{}, Tag: ""}},
			{"ascending", &gti.Field{Name: "ascending", Type: "bool", LocalType: "bool", Doc: "", Directives: gti.Directives{}, Tag: ""}},
		}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
			{"error", &gti.Field{Name: "error", Type: "error", LocalType: "error", Doc: "", Directives: gti.Directives{}, Tag: ""}},
		})}},
		{"FilterColName", &gti.Method{Name: "FilterColName", Doc: "FilterColName filters the indexes into our Table according to values in\ngiven column name, using string representation of column values.\nIncludes rows with matching values unless exclude is set.\nIf contains, only checks if row contains string; if ignoreCase, ignores case.\nUse named args for greater clarity.\nOnly valid for 1-dimensional columns.\nReturns error if column name not found.", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
			{"colNm", &gti.Field{Name: "colNm", Type: "string", LocalType: "string", Doc: "", Directives: gti.Directives{}, Tag: ""}},
			{"str", &gti.Field{Name: "str", Type: "string", LocalType: "string", Doc: "", Directives: gti.Directives{}, Tag: ""}},
			{"exclude", &gti.Field{Name: "exclude", Type: "bool", LocalType: "bool", Doc: "", Directives: gti.Directives{}, Tag: ""}},
			{"contains", &gti.Field{Name: "contains", Type: "bool", LocalType: "bool", Doc: "", Directives: gti.Directives{}, Tag: ""}},
			{"ignoreCase", &gti.Field{Name: "ignoreCase", Type: "bool", LocalType: "bool", Doc: "", Directives: gti.Directives{}, Tag: ""}},
		}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
			{"error", &gti.Field{Name: "error", Type: "error", LocalType: "error", Doc: "", Directives: gti.Directives{}, Tag: ""}},
		})}},
		{"AddRows", &gti.Method{Name: "AddRows", Doc: "AddRows adds n rows to end of underlying Table, and to the indexes in this view", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
			{"n", &gti.Field{Name: "n", Type: "int", LocalType: "int", Doc: "", Directives: gti.Directives{}, Tag: ""}},
		}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{})}},
		{"SaveCSV", &gti.Method{Name: "SaveCSV", Doc: "SaveCSV writes a table idx view to a comma-separated-values (CSV) file\n(where comma = any delimiter, specified in the delim arg).\nIf headers = true then generate C++ emergent-tyle column headers.\nThese headers have full configuration information for the tensor\ncolumns.  Otherwise, only the data is written.", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
			{"filename", &gti.Field{Name: "filename", Type: "goki.dev/gi.FileName", LocalType: "gi.FileName", Doc: "", Directives: gti.Directives{}, Tag: ""}},
			{"delim", &gti.Field{Name: "delim", Type: "github.com/goki/etable/v2/etable.Delims", LocalType: "Delims", Doc: "", Directives: gti.Directives{}, Tag: ""}},
			{"headers", &gti.Field{Name: "headers", Type: "bool", LocalType: "bool", Doc: "", Directives: gti.Directives{}, Tag: ""}},
		}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
			{"error", &gti.Field{Name: "error", Type: "error", LocalType: "error", Doc: "", Directives: gti.Directives{}, Tag: ""}},
		})}},
		{"OpenCSV", &gti.Method{Name: "OpenCSV", Doc: "OpenCSV reads a table idx view from a comma-separated-values (CSV) file\n(where comma = any delimiter, specified in the delim arg),\nusing the Go standard encoding/csv reader conforming to the official CSV standard.\nIf the table does not currently have any columns, the first row of the file\nis assumed to be headers, and columns are constructed therefrom.\nThe C++ emergent column headers are parsed -- these have full configuration\ninformation for tensor dimensionality.\nIf the table DOES have existing columns, then those are used robustly\nfor whatever information fits from each row of the file.", Directives: gti.Directives{
			&gti.Directive{Tool: "gti", Directive: "add", Args: []string{}},
		}, Args: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
			{"filename", &gti.Field{Name: "filename", Type: "goki.dev/gi.FileName", LocalType: "gi.FileName", Doc: "", Directives: gti.Directives{}, Tag: ""}},
			{"delim", &gti.Field{Name: "delim", Type: "github.com/goki/etable/v2/etable.Delims", LocalType: "Delims", Doc: "", Directives: gti.Directives{}, Tag: ""}},
		}), Returns: ordmap.Make([]ordmap.KeyVal[string, *gti.Field]{
			{"error", &gti.Field{Name: "error", Type: "error", LocalType: "error", Doc: "", Directives: gti.Directives{}, Tag: ""}},
		})}},
	}),
})
